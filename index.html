<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 跑酷遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
        }
        #game-canvas {
            display: block;
        }
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.5);
        }
    </style>
</head>
<body>

    <div id="ui-container" class="relative w-full h-screen">
        <canvas id="game-canvas"></canvas>

        <!-- 開始畫面 -->
        <div id="start-screen" class="overlay flex-col">
            <h1 class="text-5xl md:text-7xl font-bold mb-4 text-cyan-300">3D 方塊跑酷</h1>
            <p class="text-lg md:text-2xl mb-8">使用 <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">←</kbd> 和 <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">→</kbd> 鍵移動</p>
            <p class="text-lg md:text-2xl mb-8">按 <kbd class="px-4 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">空白鍵</kbd> 跳躍</p>
            <button id="start-button" class="px-8 py-4 bg-cyan-500 hover:bg-cyan-600 text-white font-bold rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-lg">
                開始遊戲
            </button>
        </div>

        <!-- 遊戲中介面 -->
        <div id="in-game-ui" class="absolute top-5 left-5 text-white text-3xl font-bold" style="display: none;">
            <p>分數: <span id="score">0</span></p>
        </div>

        <!-- 遊戲結束畫面 -->
        <div id="game-over-screen" class="overlay flex-col" style="display: none;">
            <h2 class="text-6xl font-bold mb-4 text-red-500">遊戲結束</h2>
            <p class="text-3xl mb-2">最終分數</p>
            <p id="final-score" class="text-5xl font-bold mb-8"></p>
            <button id="restart-button" class="px-8 py-4 bg-cyan-500 hover:bg-cyan-600 text-white font-bold rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-lg">
                重新開始
            </button>
        </div>
    </div>

    <script>
        // --- DOM 元素 ---
        const canvas = document.getElementById('game-canvas');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const inGameUI = document.getElementById('in-game-ui');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const scoreElement = document.getElementById('score');
        const finalScoreElement = document.getElementById('final-score');

        // --- Three.js 設置 ---
        let scene, camera, renderer, player, clock;
        let ground, light;
        let obstacles = [];
        let sceneryObjects = [];

        // --- 遊戲狀態 ---
        let gameState = 'waiting'; // waiting, playing, gameover
        let playerVelocity = new THREE.Vector3();
        let playerSpeed = 15;
        let score = 0;
        let jumpStrength = 12;
        let gravity = -30;
        let isJumping = false;

        // --- 跑道設定 ---
        const laneWidth = 3;
        const lanes = [-laneWidth, 0, laneWidth];
        let currentLane = 1; // 0: 左, 1: 中, 2: 右

        // --- 初始化函式 ---
        function init() {
            // 時鐘
            clock = new THREE.Clock();

            // 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50); // 深藍灰色背景
            scene.fog = new THREE.Fog(0x2c3e50, 0, 150); // 調整霧氣以匹配背景

            // 相機
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 8);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // 光源
            light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.set(0, 10, 5);
            light.castShadow = true;
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x666666, 1)); // 調整環境光

            // 地板
            createGround();

            // 玩家
            createPlayer();

            // 事件監聽
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
            
            // 進入等待畫面
            resetGame();
        }

        // --- 遊戲迴圈 ---
        function animate() {
            requestAnimationFrame(animate);

            if (gameState !== 'playing') return;

            const delta = clock.getDelta();
            
            // 玩家向前移動
            player.position.z -= playerSpeed * delta;
            
            // 更新玩家垂直方向運動 (跳躍與重力)
            if (isJumping) {
                playerVelocity.y += gravity * delta;
                player.position.y += playerVelocity.y * delta;
                
                if (player.position.y <= 1) {
                    player.position.y = 1;
                    isJumping = false;
                    playerVelocity.y = 0;
                }
            }

            // 更新玩家水平位置
            const targetX = lanes[currentLane];
            player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, 10 * delta);

            // 相機跟隨玩家
            camera.position.z = player.position.z + 8;
            camera.position.y = player.position.y + 3;

            // 產生與移除物件
            manageWorldObjects();

            // 碰撞偵測
            checkCollisions();

            // 更新分數
            score = Math.floor(-player.position.z / 10);
            scoreElement.innerText = score;

            renderer.render(scene, camera);
        }

        // --- 遊戲控制 ---
        function startGame() {
            resetGame();
            gameState = 'playing';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            inGameUI.style.display = 'block';
            animate();
        }

        function gameOver() {
            gameState = 'gameover';
            finalScoreElement.innerText = score;
            gameOverScreen.style.display = 'flex';
            inGameUI.style.display = 'none';
        }

        function resetGame() {
            // 清除障礙物
            obstacles.forEach(obj => scene.remove(obj));
            obstacles = [];

            // 清除背景物件
            sceneryObjects.forEach(obj => scene.remove(obj));
            sceneryObjects = [];

            // 重設玩家位置與狀態
            player.position.set(0, 1, 0);
            currentLane = 1;
            isJumping = false;
            playerVelocity.set(0, 0, 0);
            
            // 重設分數
            score = 0;
            scoreElement.innerText = score;
            
            // 重設相機
            camera.position.set(0, 4, 8);
        }

        // --- 物件創建 ---
        function createPlayer() {
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshLambertMaterial({ color: 0xf1c40f }); // 亮黃色
            player = new THREE.Mesh(geometry, material);
            player.position.y = 1;
            player.castShadow = true;
            scene.add(player);
        }
        
        function createGround() {
             const groundGeometry = new THREE.PlaneGeometry(30, 10000);
             const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x34495e }); // 深色地板
             ground = new THREE.Mesh(groundGeometry, groundMaterial);
             ground.rotation.x = -Math.PI / 2;
             ground.receiveShadow = true;
             scene.add(ground);
        }

        function createObstacle(z, lane) {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshLambertMaterial({ color: 0xff4444 });
            const obstacle = new THREE.Mesh(geometry, material);
            obstacle.position.set(lanes[lane], 1, z);
            obstacle.castShadow = true;
            obstacles.push(obstacle);
            scene.add(obstacle);
        }

        function createSceneryObject(z) {
            const buildingColors = [0xbdc3c7, 0x95a5a6, 0x7f8c8d];
            const height = Math.random() * 20 + 5;
            const width = Math.random() * 5 + 2;
            
            const geometry = new THREE.BoxGeometry(width, height, width);
            const material = new THREE.MeshLambertMaterial({ color: buildingColors[Math.floor(Math.random() * buildingColors.length)] });
            
            // 左側建築
            const buildingLeft = new THREE.Mesh(geometry, material);
            const leftX = -(laneWidth * 2) - Math.random() * 10 - width / 2;
            buildingLeft.position.set(leftX, height / 2, z);
            sceneryObjects.push(buildingLeft);
            scene.add(buildingLeft);

            // 右側建築
            const buildingRight = buildingLeft.clone();
            const rightX = (laneWidth * 2) + Math.random() * 10 + width / 2;
            buildingRight.position.x = rightX;
            sceneryObjects.push(buildingRight);
            scene.add(buildingRight);
        }

        // --- 邏輯函式 ---
        
        // 管理世界物件（產生/移除）
        function manageWorldObjects() {
            const spawnDistance = -50;
            const despawnDistance = 20;
            const playerZ = player.position.z;

            // 移除遠離的障礙物
            obstacles = obstacles.filter(obstacle => {
                if (obstacle.position.z > playerZ + despawnDistance) {
                    scene.remove(obstacle);
                    return false;
                }
                return true;
            });

            // 隨機產生新的障礙物
            const lastObstacleZ = obstacles.length > 0 ? obstacles[obstacles.length - 1].position.z : 0;
            if (lastObstacleZ > playerZ + spawnDistance) {
                 const newZ = lastObstacleZ - 10 - Math.random() * 15;
                 const newLane = Math.floor(Math.random() * 3);
                 createObstacle(newZ, newLane);
                 // 有時一次產生兩個
                 if(Math.random() > 0.6) {
                     let newLane2;
                     do {
                         newLane2 = Math.floor(Math.random() * 3);
                     } while (newLane2 === newLane);
                     createObstacle(newZ, newLane2);
                 }
            }

            // --- 管理背景物件 ---
            sceneryObjects = sceneryObjects.filter(obj => {
                if (obj.position.z > playerZ + despawnDistance) {
                    scene.remove(obj);
                    return false;
                }
                return true;
            });

            // 隨機產生新的背景物件
            const lastSceneryZ = sceneryObjects.length > 0 ? sceneryObjects[sceneryObjects.length - 1].position.z : 0;
            if (lastSceneryZ > playerZ + spawnDistance) {
                 const newZ = lastSceneryZ - 20 - Math.random() * 20;
                 createSceneryObject(newZ);
            }
        }
        
        function checkCollisions() {
            const playerBox = new THREE.Box3().setFromObject(player);
            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    gameOver();
                    return;
                }
            }
        }
        
        // --- 事件處理 ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (gameState !== 'playing') return;

            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    if (currentLane > 0) currentLane--;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    if (currentLane < lanes.length - 1) currentLane++;
                    break;
                case 'Space':
                    if (!isJumping) {
                        isJumping = true;
                        playerVelocity.y = jumpStrength;
                    }
                    break;
            }
        }

        // --- 啟動遊戲 ---
        init();

    </script>
</body>
</html>

